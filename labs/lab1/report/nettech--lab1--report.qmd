---
# Preamble

## Author
author:
  name: Калашникова Ольга Сергеевна
  email: 1132231846@rudn.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6
## Title
title: "Отчёт по лабораторной работе №1"
subtitle: "Дисциплина: Сетевые технологии"
license: "CC BY"
## Generic options
lang: ru-RU
number-sections: true
toc: true
toc-title: "Содержание"
toc-depth: 2
## Crossref customization
crossref:
  lof-title: "Список иллюстраций"
  lot-title: "Список таблиц"
  lol-title: "Листинги"
## Bibliography
bibliography:
  - bib/cite.bib
csl: _resources/csl/gost-r-7-0-5-2008-numeric.csl
## Formats
format:
### Pdf output format
  pdf:
    toc: true
    number-sections: true
    colorlinks: false
    toc-depth: 2
    lof: true # List of figures
    lot: true # List of tables
#### Document
    documentclass: scrreprt
    papersize: a4
    fontsize: 12pt
    linestretch: 1.5
#### Language
    babel-lang: ru
    babel-otherlangs: en
#### Biblatex
    cite-method: biblatex
    biblio-style: gost-numeric
    biblatexoptions:
      - backend=biber
      - langhook=extras
      - autolang=other*
#### Misc options
    csquotes: true
    indent: true
    header-includes: |
      \usepackage{indentfirst}
      \usepackage{float}
      \floatplacement{figure}{H}
      \usepackage[math,RM={Scale=0.94},SS={Scale=0.94},SScon={Scale=0.94},TT={Scale=MatchLowercase,FakeStretch=0.9},DefaultFeatures={Ligatures=Common}]{plex-otf}
### Docx output format
  docx:
    toc: true
    number-sections: true
    toc-depth: 2
---

# Цель работы

Изучение методов кодирования и модуляции сигналов с помощью высоко-уровнего языка программирования Octave. Определение спектра и параметров сигнала. Демонстрация принципов модуляции сигнала на примере аналоговой амплитудной модуляции. Исследование свойства самосинхронизации сигнала.

# Задание

1. Построить график функции sin, используя Octave и функцию plot. График экспортировать в файлы
формата .eps, .png.

2. Добавить график функции cos и экспортировать в файлы формата .eps, .png.

3. Разработать код m-файла, результатом выполнения которого являются графики меандра, реализованные с различным количеством гармоник.

# Выполнение лабораторной работы

## Построение графиков в Octave

Запустиv Octave с оконным интерфейсом. Перейдём в окно редактора. Воспользовавшись комбинацией клавиш ctrl + n создадим новый сценарий. Сохраним его в рабочий каталог с именем plot_sin.m. В окне редактора повторим листинг по построению графика функции sin ([рис. @fig-001]) 

![Построение графика sin](image/1.png){#fig-001 width=70%}

Запустим сценарий на выполнение. В качестве результата выполнения кода открылось окно с построенным графиком ([рис. @fig-002]) 

![График sin](image/2.png){#fig-002 width=70%}

В рабочем каталоге появились файлы с графиками в форматах .eps, .png. ([рис. @fig-003]) 

![Изменение рабочего каталога](image/3.png){#fig-003 width=70%}

Сохраним сценарий под другим названием и изменим его так, чтобы на одном графике располагались отличающиеся по типу линий графики функций с sin и cos ([рис. @fig-004]) 

![Построение графика sin и cos](image/4.png){#fig-004 width=70%}

Получаем изображение с двумя графиками ([рис. @fig-005]) 

![Построение графика sin и cos](image/5.png){#fig-005 width=70%}

## Разложение импульсного сигнала в частичный ряд Фурье

Создадим новый сценарий и сохраним его в рабочий каталог с именем `meandr.m`. В ходе созданного сценария зададим начальные значения:

```matlab
% meandr.m
% количество отсчетов (гармоник):
N=8;
% частота дискретизации:
t=-1:0.01:1;
% значение амплитуды:
A=1;
% период:
T=1;
```

В спектре присутствуют только нечётные гармоники. Гармоники, образующие меандр, имеют амплитуду, обратно пропорциональную номеру соответствующей гармоники в спектре.

```matlab
% амплитуда гармоник
nh=(1:N)*2-1;

% массив коэффициентов для ряда, заданного через cos:
Am=2/pi ./ nh;
Am(2:2:end) = -Am(2:2:end);
```

Зададим массив значений гармоник и массив элементов ряда:

```matlab
% массив гармоник:
harmonics=cos(2 * pi * nh' * t/T);
% массив элементов ряда:
sl=harmonics.*repmat(Am',1,length(t));
```

Для построения в одном окне отдельных графиков меандра с различным количеством гармоник реализуем суммирование ряда с накоплением и воспользуемся функциями `subplot` и `plot` для построения графиков:

```matlab
% Суммирование ряда:
s2=cumsum(s1);
% Построение графиков:
for k=1:N
    subplot(4,2,k)
    plot(t, s2(k,:))
end
```

Получаем итоговый код ([рис. @fig-006]) 

![Код для разложения меандра](image/6.png){#fig-006 width=70%}

Запустим сценарий на выполнение. Получим графики меандра, содержащие различное количество гармоник (от 1 до 8). ([рис. @fig-007]) 

![Графики меандра с различным числом гармоник](image/7.png){#fig-007 width=70%}

Экспортируем полученный график в файл в формате .png. Скорректируем код для реализации меандра через синусы. Получим соответствующие графики.([рис. @fig-008]) 

![Графики меандра с различным числом гармоник(синусы)](image/meandr2.png){#fig-008 width=70%}

## Определение спектра и параметров сигнала

Создадим каталог `spectrel` и в нём новый сценарий с именем `spectre.m`. В коде созданного сценария зададим начальные значения:

```matlab
% spectrel/spectre.m
% Создание каталогов signal и spectre для размещения графиков:
mkdir 'signal';
mkdir 'spectre';

% Длина сигнала (с):
tmax = 0.5;
% Частота дискретизации (Гц) (количество отсчётов):
fd = 512;
% Частота первого сигнала (Гц):
f1 = 10;
% Частота второго сигнала (Гц):
f2 = 40;
% Амплитуда первого сигнала:
a1 = 1;
% Амплитуда второго сигнала:
a2 = 0.7;
% Массив отсчётов времени:
t = 0:1./fd:tmax;
% Спектр сигнала:
fd2 = fd/2;
```

![Код для создания двух сигналов и каталогов](image/9.png){#fig-009 width=70%}

Зададим два синусоидальных сигнала разной частоты:

```matlab
% Два сигнала разной частоты:
signal1 = a1*sin(2*pi*t*f1);
signal2 = a2*sin(2*pi*t*f2);
```

Построим графики сигналов:

```matlab
% График 1-го сигнала:
plot(signal1,'b');
% График 2-го сигнала:
hold on
plot(signal2,'r');
hold off
title('Signal');

% Экспорт графика в файл в каталоге signal:
print 'signal/spectre.png';
```

![Два синусоидальных сигнала разной частоты](image/signal/spectre.png){#fig-010 width=70%}

С помощью быстрого преобразования Фурье найдём спектры сигналов:

```matlab
% Посчитаем спектр
% Амплитуды преобразования Фурье сигнала 1:
spectrel = abs(fft(signal1,fd));
% Амплитуды преобразования Фурье сигнала 2:
spectre2 = abs(fft(signal2,fd));
% Построение графиков спектров сигналов:
plot(spectrel,'b');
hold on
plot(spectre2,'r');
hold off
title('Spectre');
print 'spectre/spectre.png';
```

![Код для расчёта спектров](image/11.png){#fig-011 width=70%}

![График спектров синусоидальных сигналов](image/spectre/spectre.png){#fig-012 width=70%}

Учитывая реализацию преобразования Фурье, скорректируем график спектра: отбросим дублирующие отрицательные частоты, а также примем в расчёт то, что на каждом шаге вычисления быстрого преобразования Фурье происходит суммирование амплитуд сигналов. Для этого добавим в файл `spectre.m` следующий код:

```matlab
% Исправление графика спектра
% Сетка частот:
f = 1000*(0:fd2)./(2*fd);
% Нормировка спектров по амплитуде:
spectrel = 2*spectrel/fd2;
spectre2 = 2*spectre2/fd2;
% Построение графиков спектров сигналов:
plot(f,spectrel(1:fd2+1),'b');
hold on
plot(f,spectre2(1:fd2+1),'r');
hold off
xlim([0 100]);
title('Fixed spectre');
xlabel('Frequency (Hz)');
print 'spectre/spectre_fix.png';
```

![Код для исправления графика спектра](image/13.png){#fig-013 width=70%}

![Исправленный график спектров синусоидальных сигналов](image/spectre/spectre_fix.png){#fig-014 width=70%}

Найдём спектр суммы рассмотренных сигналов. Создадим каталог `spectr_sum` и файл в нём `spectre_sum.m` со следующим кодом:

```matlab
% spectr_sum/spectre_sum.m
% Создание каталогов signal и spectre для размещения графиков:
mkdir 'signal';
mkdir 'spectre';
% Длина сигнала (с):
tmax = 0.5;
% Частота дискретизации (Гц) (количество отсчётов):
fd = 512;
% Частота первого сигнала (Гц):
f1 = 10;
% Частота второго сигнала (Гц):
f2 = 40;
% Амплитуда первого сигнала:
a1 = 1;
% Амплитуда второго сигнала:
a2 = 0.7;
% Спектр сигнала:
fd2 = fd/2;

% Сумма двух сигналов (синусоиды) разной частоты:
% Массив отсчётов времени:
t = 0:1./fd:tmax;
signal1 = a1*sin(2*pi*t*f1);
signal2 = a2*sin(2*pi*t*f2);
signal = signal1 + signal2;
plot(signal);
title('Signal');
print 'signal/spectre_sum.png';
```

![Код для суммы сигналов и расчёта её спектра](image/15.png){#fig-015 width=70%}

![Суммарный сигнал](image/signal/spectre_sum.png){#fig-016 width=70%}

Подсчитаем спектр суммы сигналов:

```matlab
% Подсчет спектра:
% Амплитуды преобразования Фурье сигнала:
spectre = fft(signal,fd);
% Сетка частот:
f = 1000*(0:fd2)./(2*fd);

% Нормировка спектра по амплитуде:
spectre = 2*sqrt(spectre.*conj(spectre))./fd2;
% Построение графика спектра сигнала:
plot(f,spectre(1:fd2+1))
xlim([0 100]);
title('Spectre');
xlabel('Frequency (Hz)');
print 'spectre/spectre_sum.png';
```

![Спектр суммарного сигнала](image/spectre/spectre_sum.png){#fig-017 width=70%}

В результате получился аналогичный предыдущему результат, т.е. спектр суммы сигналов оказался равен сумме спектров сигналов, что вытекает из свойств преобразования Фурье.

## Амплитудная модуляция

Создадим в рабочем каталоге каталог `modulation` и в нём новый сценарий с именем `am.m`. Добавим в файл `am.m` следующий код:

```matlab
% modulation/am.m
% Создание каталогов signal и spectre для размещения графиков:
mkdir 'signal';
mkdir 'spectre';

% Модуляция синусоид с частотами 50 и 5
% Длина сигнала (с):
tmax = 0.5;
% Частота дискретизации (Гц) (количество отсчётов):
fd = 512;
% Частота сигнала (Гц):
f1 = 5;
% Частота несущей (Гц):
f2 = 50;
% Спектр сигнала:
fd2 = fd/2;
% Построение графиков двух сигналов (синусоиды) разной частоты
% Массив отсчётов времени:
t = 0:1./fd:tmax;
signal1 = sin(2*pi*t*f1);
signal2 = sin(2*pi*t*f2);
signal = signal1 .* signal2;
plot(signal, 'b');
hold on
% Построение огибающей:
plot(signal1, 'r');
plot(-signal1, 'r');
hold off
title('Signal');
print 'signal/am.png';
```

![Код для амплитудной модуляции](image/18.png){#fig-018 width=70%}

![Сигнал и огибающая при амплитудной модуляции](image/signal/am.png){#fig-019 width=70%}

Выполним расчёт спектра амплитудно-модулированного сигнала:

```matlab
% Расчет спектра:
% Амплитуды преобразования Фурье-сигнала:
spectre = fft(signal,fd);
% Сетка частот:
f = 1000*(0:fd2)./(2*fd);
% Нормировка спектра по амплитуде:
spectre = 2*sqrt(spectre.*conj(spectre))./fd2;
% Построение спектра:
plot(f,spectre(1:fd2+1), 'b')
xlim([0 100]);
title('Spectre');
xlabel('Frequency (Hz)');
print 'spectre/am.png';
```

![Спектр сигнала при амплитудной модуляции](image/spectre/am.png){#fig-020 width=70%}

В результате получили, что спектр произведения представляет собой свёртку спектров. На спектре амплитудно-модулированного сигнала видны боковые полосы вокруг несущей частоты 50 Гц, что соответствует теории амплитудной модуляции.

## Кодирование сигнала. Исследование свойства самосинхронизации сигнала

Создадим в рабочем каталоге каталог `coding` и в нём файлы `main.m`, `maptowave.m`, `unipolar.m`, `ami.m`, `bipolarmrz.m`, `bipolarrz.m`, `manchester.m`, `diffmanc.m`, `calcspectre.m`.

Проверим в окне интерпретатора команд, установлен ли пакет расширений `signal`:

```
>> pkg list
```

![Проверка установленных пакетов](image/22.png){#fig-021 width=70%}

Как видно из вывода, пакет `signal` версии 1.4.5 уже установлен.

![Файлы в каталоге coding](image/21.png){#fig-022 width=70%}

В файле `main.m` подключим пакет `signal` и зададим входные кодовые последовательности:

```matlab
% coding/main.m
% Подключение пакета signal:
pkg load signal;

% Входная кодовая последовательность:
data=[0 1 0 0 1 1 0 0 0 1 1 0];
% Входная кодовая последовательность для проверки свойства самосинхронизации:
data_sync=[0 0 0 0 0 0 1 1 1 1 1 1];
% Входная кодовая последовательность для построения спектра сигнала:
data_spectre=[0 1 0 1 0 1 0 1 0 1 0 1 0 1];

% Создание каталогов signal, sync и spectre для размещения графиков:
mkdir 'signal';
mkdir 'sync';
mkdir 'spectre';
axis("auto");
```

![Код основного скрипта - часть 1](image/23.png){#fig-023 width=70%}

Затем в этом же файле пропишем вызовы функций для построения графиков модуляций кодированных сигналов для кодовой последовательности `data`:

```matlab
% Униполярное кодирование
wave=unipolar(data);
plot(wave);
ylim([-1 6]);
title('Unipolar');
print 'signal/unipolar.png';

% Кодирование ami
wave=ami(data);
plot(wave)
title('AMI');
print 'signal/ami.png';

% Кодирование NRZ
wave=bipolarmrz(data);
plot(wave);
title('Bipolar Non-Return to Zero');
print 'signal/bipolarmrz.png';

% Кодирование RZ
wave=bipolarrz(data);
plot(wave)
title('Bipolar Return to Zero');
print 'signal/bipolarrz.png';

% Манчестерское кодирование
wave=manchester(data);
plot(wave)
title('Manchester');
print 'signal/manchester.png';

% Дифференциальное манчестерское кодирование
wave=diffmanc(data);
plot(wave)
title('Differential Manchester');
print 'signal/diffmanc.png';
```

![Код основного скрипта - часть 2](image/24.png){#fig-024 width=70%}

Затем в этом же файле пропишем вызовы функций для построения графиков модуляций кодированных сигналов для кодовой последовательности `data_sync`:

```matlab
% Униполярное кодирование
wave=unipolar(data_sync);
plot(wave);
ylim([-1 6]);
title('Unipolar');
print 'sync/unipolar.png';

% Кодирование AMI
wave=ami(data_sync);
plot(wave)
title('AMI');
print 'sync/ami.png';

% Кодирование NRZ
wave=bipolarmrz(data_sync);
plot(wave);
title('Bipolar Non-Return to Zero');
print 'sync/bipolarmrz.png';

% Кодирование RZ
wave=bipolarrz(data_sync);
plot(wave)
title('Bipolar Return to Zero');
print 'sync/bipolarrz.png';

% Манчестерское кодирование
wave=manchester(data_sync);
plot(wave)
title('Manchester');
print 'sync/manchester.png';

% Дифференциальное манчестерское кодирование
wave=diffmanc(data_sync);
plot(wave)
title('Differential Manchester');
print 'sync/diffmanc.png';
```

![Код основного скрипта - часть 3](image/25.png){#fig-025 width=70%}

Далее в этом же файле пропишем вызовы функций для построения графиков спектров:

```matlab
% Униполярное кодирование:
wave=unipolar(data_spectre);
spectre=calcspectre(wave);
title('Unipolar');
print 'spectre/unipolar.png';

% Кодирование AMI:
wave=ami(data_spectre);
spectre=calcspectre(wave);
title('AMI');
print 'spectre/ami.png';

% Кодирование NRZ:
wave=bipolarmrz(data_spectre);
spectre=calcspectre(wave);
title('Bipolar Non-Return to Zero');
print 'spectre/bipolarmrz.png';

% Кодирование RZ:
wave=bipolarrz(data_spectre);
spectre=calcspectre(wave);
title('Bipolar Return to Zero');
print 'spectre/bipolarrz.png';

% Манчестерское кодирование:
wave=manchester(data_spectre);
spectre=calcspectre(wave);
title('Manchester');
print 'spectre/manchester.png';

% Дифференциальное манчестерское кодирование:
wave=diffmanc(data_spectre);
spectre=calcspectre(wave);
title('Differential Manchester');
print 'spectre/diffmanc.png';
```

![Код основного скрипта - часть 4](image/26.png){#fig-026 width=70%}

```matlab
% coding/maptowave.m
function wave=maptowave(data)
    data=upsample(data,100);
    wave=filter(5*ones(1,100),1,data);
```

![Функция maptowave.m](image/27.png){#fig-027 width=70%}

```matlab
% coding/unipolar.m
% Униполярное кодирование:
function wave=unipolar(data)
    wave=maptowave(data);
```

```matlab
% coding/ami.m
% Кодирование AMI:
function wave=ami(data)
    am=mod(1:length(data(data==1)),2);
    am(am==0)=-1;
    data(data==1)=am;
    wave=maptowave(data);
```

![Функция ami.m](image/29.png){#fig-029 width=70%}

```matlab
% coding/bipolarmrz.m
% Кодирование NRZ:
function wave=bipolarmrz(data)
    data(data==0)=-1;
    wave=maptowave(data);
```

![Функция bipolarmrz.m](image/30.png){#fig-030 width=70%}

```matlab
% coding/bipolarrz.m
% Кодирование RZ:
function wave=bipolarrz(data)
    data(data==0)=-1;
    data=upsample(data,2);
    wave=maptowave(data);
```

![Функция bipolarrz.m](image/31.png){#fig-031 width=70%}

```matlab
% coding/manchester.m
% Манчестерское кодирование:
function wave=manchester(data)
    data(data==0)=-1;
    data=upsample(data,2);
    data=filter([-1 1],1,data);
    wave=maptowave(data);
```

![Функция manchester.m](image/32.png){#fig-032 width=70%}

```matlab
% coding/diffmanc.m
% Дифференциальное манчестерское кодирование
function wave=diffmanc(data)
    data=filter(1,[1 1],data);
    data=mod(data,2);
    wave=manchester(data);
```

![Функция diffmanc.m](image/33.png){#fig-033 width=70%}

```matlab
% calcspectre.m
% Функция построения спектра сигнала:
function spectre = calcspectre(wave)
    % Частота дискретизации (Гц):
    Fd = 512;
    Fd2 = Fd/2;
    Fd3 = Fd/2 + 1;

    X = fft(wave,Fd);
    spectre = X.*conj(X)/Fd;
    f = 1000*(0:Fd2)/Fd;
    plot(f,spectre(1:Fd3));
    xlabel('Frequency (Hz)');
```

![Функция calcspectre.m](image/34.png){#fig-034 width=70%}

Запустим главный скрипт `main.m`. В каталоге `signal` получим файлы с графиками кодированного сигнала, в каталоге `sync` — файлы с графиками, иллюстрирующими свойства самосинхронизации, в каталоге `spectre` — файлы с графиками спектров сигналов.

Графики кодированных сигналов

![Униполярное кодирование](image/signal/unipolar.png){#fig-035 width=70%}

![Кодирование AMI](image/signal/ami.png){#fig-036 width=70%}

![Кодирование NRZ](image/signal/bipolarnrz.png){#fig-037 width=70%}

![Кодирование RZ](image/signal/bipolarrz.png){#fig-038 width=70%}

![Манчестерское кодирование](image/signal/manchester.png){#fig-039 width=70%}

![Дифференциальное манчестерское кодирование](image/signal/diffmanc.png){#fig-040 width=70%}

Графики, иллюстрирующие свойства самосинхронизации

![Униполярное кодирование: нет самосинхронизации](image/sync/unipolar.png){#fig-041 width=70%}

![Кодирование AMI: самосинхронизация при наличии сигнала](image/sync/ami.png){#fig-042 width=70%}

![Кодирование NRZ: нет самосинхронизации](image/sync/bipolarnrz.png){#fig-043 width=70%}

![Кодирование RZ: есть самосинхронизация](image/sync/bipolarrz.png){#fig-044 width=70%}

![Манчестерское кодирование: есть самосинхронизация](image/sync/manchester.png){#fig-045 width=70%}

![Дифференциальное манчестерское кодирование: есть самосинхронизация](image/sync/diffmanc.png){#fig-046 width=70%}

Спектры сигналов

![Униполярное кодирование: спектр сигнала](image/spectre/unipolar.png){#fig-047 width=70%}

![Кодирование AMI: спектр сигнала](image/spectre/ami.png){#fig-048 width=70%}

![Кодирование NRZ: спектр сигнала](image/spectre/bipolarnrz.png){#fig-049 width=70%}

![Кодирование RZ: спектр сигнала](image/spectre/bipolarrz.png){#fig-050 width=70%}

![Манчестерское кодирование: спектр сигнала](image/spectre/manchester.png){#fig-051 width=70%}

![Дифференциальное манчестерское кодирование: спектр сигнала](image/spectre/diffmanc.png){#fig-052 width=70%}

# Выводы

В ходе выполнения лабораторной работы были получены практические знания о методах кодирования и модуляции сигналов с помощью языка программирования Octave. Было выполнено определение спектра и параметров сигнала с использованием быстрого преобразования Фурье, что подтвердило свойство линейности данного преобразования. На примере амплитудной модуляции продемонстрированы принципы модуляции сигналов, получены модулированный сигнал и его спектр с характерными боковыми полосами. Исследовано свойство самосинхронизации сигнала для различных методов кодирования, установлено, что коды с регулярными переходами обеспечивают надёжную синхронизацию. Работа подтвердила возможность использования Octave как эффективного инструмента для анализа и обработки сигналов в области телекоммуникаций.
